# 주문 API 설계와 성능 병목 분석: 실무에서 마주한 문제 해결하기

## 얻고자 하는 것

- API 설계에서 어떤 방식이 장기적으로 관리 및 확장에 유리한지에 대한 가이드를 얻고 싶어요. 특히, 결합된 데이터를 어떻게 효율적으로 관리할지에 대한 다양한 아이디어를 듣고 싶어요.
- 성능 테스트를 통해 병목 현상을 해결할 때, 어떤 전략이 효과적이었는지 구체적인 방법론을 공유받고자 하는 것이에요.

## 1. 주문 API 설계 → 특정 주문의 상세 정보를 조회하는 API

주문 목록에서 특정 주문의 상세 정보를 조회할 때, 해당 주문에 포함된 상품의 상세 정보를 반환하는 API 응답값이에요. 실제로 운영 중인 서비스 라고 가정해볼게요. 🔥

주문 상세 응답에서 필드가 `10개` 이상이에요.
응답값을 보면 **주문 정보, 상품 정보, 배송 정보, 환불 정보**가 결합되어 있는 형태예요.

모놀리스 아키텍처와 마이크로 서비스 아키텍처일 때,

**여러 도메인을 어떻게 결합하는 코드를 만드는 게 좋을지 궁금해요. 어떻게 구현할지 의견 부탁드려요.**

> 아래 코드는 예시입니다. [예시 코드](https://github.com/sipe-team/3-1_spurt/tree/main/playground/devfancy/java-springboot-order-perf-optimizer)

```java
// 특정 주문의 상세 정보를 조회하는 API에 사용하는 DTO
@Getter
public class OrderDetailsResponse {

    private List<OrderItemDto> orderItems;

    public OrderDetailsResponse(final List<OrderItemDto> orderItems) {
        this.orderItems = orderItems;
    }

    class OrderItemDto {
        class ProductBundleDetailDto {
            // 상품 정보: 상품의 묶음 관련 상세 정보(상품 묶음 이름, 해당 묶음에 포함된 상품의 수량)
        }
        class ProductDetailsDto {
            // 상품 정보: 실제 상품의 상세 정보 (상품 이름, 상품 설명, 상품 가격 등)
        }
        class DeliveryDetailsDto {
            // 배송 정보: 배송과 관련된 상세 정보(받으실 분, 연락처, 배송 주소, 우편 번호, 가게 비밀 번호, 배송 메모 등)
        }
        class RefundDetailsDto {
            // 환불 정보: 환불 관련 상세 정보 (환불 수단, 환불 총 금액, 환불 처리 상태 등)
        }
    }
}
```

처음에는 주문 상품의 상세 정보만 보여주면 되었는데, 시간이 지나면서 요구사항이 점차 늘어났어요. 주문 상품 상세에 배송 상태와 배송 예정일을 추가해 달라는 요청이 들어왔고, 환불 관련 세부 정보도 필요하게 되었어요.

- 주문, 상품, 배송, 환불 도메인이 함께 있어요.

**모놀리스**일 때는 각 도메인을 서비스 호출해서 DB에서 조회해오면 되는 상황이에요.

**마이크로 서비스**일 때는 각 도메인을 HTTP를 통해 조회해야 하는 상황이에요.

- 어그리게이션을 어떻게 하는 게 좋을까요?
    - 주문 → 주문 상품과 다른 도메인들을 어떻게 결합할지 고민이 필요해요. 보통 주문 상품에서 스냅샷으로 다 들고 있거나, 주문 상품에서 실시간으로 조회하기 위한 ID만 갖고 있는 경우가 있어요. 구현 방향에 따라 다를 것 같아요.
- 응답값을 어떻게 표현하고 조립하면 나중을 위해 건강한 구조가 될까요?

**백엔드뿐만 아니라 `프론트엔드 관점`에서도 해결 방안이 다양할 것 같아요!**

---

아래 후보들은 제 생각을 정리한 내용이에요. 읽어보시고 더 좋은 방안이 있으면 댓글로 알려주셔도 좋고, 추가해 주셔도 좋아요. (일부는 실무에서 사용하면 안 되는, 문제가 될 수 있는 방안도 포함되어 있어요)

정답은 없고, 상황과 조직 규모에 따라 의견이 다를 것 같아요.

### 후보 1

- 응답 response의 setter를 열어두고 각 object를 가져와 필드들을 한 곳에서 set해요.
    - 현재 구조의 문제점은 각 도메인이 뒤엉켜 응답 object를 만드는 거예요. 이를 개선하면 좋겠어요.
    - 각 도메인별로 응답을 만드는 걸 분리하는 게 나을 것 같아요.

### 후보 2

- 응답 response의 setter를 열어두고 각 object를 가져올 때마다 각 필드를 set해요. object마다 loop를 돌려야 해요.
    - 상품 루프 돌고, 환불 루프 돌고, 배송 루프를 돌면서 응답값에 set하는 형태예요. API 하나로 모든 걸 해결하는 방식이에요.

### 후보 3

- 응답 response의 setter를 막아버리고, 각 object를 가져와 생성자 파라미터로 넘겨서 응답을 만들어요.
    - JSON 응답에 대한 필드를 한곳에서 set/설정하게 돼요.
    - 각 object에 대한 필드 설정이 40줄 정도 한 곳에 모일 수 있어요.
    - 각 도메인별로 응답을 분리하지 않고, 한 곳에서 요약하는 형태예요.
- 주문 상세처럼 복잡한 API에서는 NoSQL(몽고DB)을 사용해 응답을 한 번에 관리하는 방법도 고려할 수 있어요.
    - 참고) 대규모 트랜잭션을 처리하는 배민 주문시스템 **24:13 ~ 25:30** (2023 우아콘) -> 해당 영상도 도움이 됐어요!

### 후보 4

- 응답 response를 각 object로 나눠서 프론트에서 여러 번 호출하게 해요.
    - 캐시를 하면 성능이 더 좋아져서 프론트에 요구할 수 있어요.
    - 백엔드에서 상품팀, 주문팀, 환불팀, 배송팀이 분리돼 있으면 프론트에서 따로 호출하는 그림이 그려질 거예요.
    - 추후 확장성이나 관리 주체를 생각하면 API가 아예 분리되는 게 더 좋을 수 있겠어요.

---

프론트에서 보여줘야 하는 요구사항에 따라 달라질 수 있겠어요.

- 백엔드에서 상품/주문/배송/환불 정보를 모아서 보내는 방법이 있어요. 이 경우 백엔드에서 여러 번 HTTP 콜을 날려야 해요.
- 프론트에서 백엔드를 여러 번 호출해 각각 상품/주문/배송/환불 정보를 얻는 방법도 있을 거예요.
    - 화면에 상품/주문/배송/환불 데이터가 한 번에 다 보여야 하고, 빠진 데이터가 없어야 한다면 백엔드에서 모아서 제공해야겠어요.
    - 배송 데이터는 늦게 보여도 되는 상황이라면, 프론트에서 따로 호출해도 괜찮을 것 같아요.


## 2. 성능 테스트 관점

위의 질문을 통해 답변이 끝났다면, 이제는 성능 테스트 관점에서 바라볼까요?

주문, 상품, 배송, 환불 정보를 결합하는 과정에서 발생할 수 있는 주요 병목 현상은 아래와 같아요.

- **캐시 전략 부족**: 빈번하게 조회되는 데이터에 대해 캐시를 사용하지 않으면, 매번 DB를 호출해야 해서 성능이 저하될 수 있어요. 적절한 캐싱 전략이 필요해요.
- **데이터베이스 쿼리 병목**: 여러 도메인을 결합하게 되면서 복잡한 조인 쿼리와 반복적인 DB 호출로 인한 성능 저하가 발생할 수있음
- **서비스 간 호출의 Latency**: 마이크로서비스 아키텍처에서는 여러 서비스 간의 네트워크 호출이 필요해요. 이때 지연(latency) 문제가 발생할 수 있어요. 특히, 복잡한 서비스 호출 체인이 있다면 호출 시간을 분석하고 최적화하는 작업이 필요해요.

이 외에도 다른 여러 문제들도 있을 거에요. 혹시 생각한게 있으시다면 알려주세요!

---

## 참고자료

- [대규모 트랜잭션을 처리하는 배민 주문시스템 규모에 따른 진화](https://www.youtube.com/watch?v=704qQs6KoUk&ab_channel=%EC%9A%B0%EC%95%84%ED%95%9C%ED%85%8C%ED%81%AC)
- [대용량 트래픽 아니면 안보셔도 됩니다! 선물하기 서비스 캐싱 전략 / if(kakaoAI) 2024](https://www.youtube.com/watch?v=BUV4A2F9i7w&t=1s&ab_channel=kakaotech)
